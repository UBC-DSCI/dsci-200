{
  "hash": "c994b3782aa82a81d3dc061985d354d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlecture: \"Simulations - part I\"\nformat: revealjs\nmetadata-files: \n  - _metadata.yml\n---\n\n\n## {{< meta lecture >}} {.large background-image=\"img/smooths.png\" background-opacity=\"0.3\" background-size=\"50%\"}\n\n[DSCI 200]{.secondary}\n\n[{{< meta author >}}]{.secondary}\n\nLast modified -- 19 January 2026\n\n\n\n\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\DeclareMathOperator*{\\minimize}{minimize}\n\\DeclareMathOperator*{\\maximize}{maximize}\n\\DeclareMathOperator*{\\find}{find}\n\\DeclareMathOperator{\\st}{subject\\,\\,to}\n\\newcommand{\\E}{E}\n\\newcommand{\\Expect}[1]{\\E\\left[ #1 \\right]}\n\\newcommand{\\Var}[1]{\\mathrm{Var}\\left[ #1 \\right]}\n\\newcommand{\\Cov}[2]{\\mathrm{Cov}\\left[#1,\\ #2\\right]}\n\\newcommand{\\given}{\\ \\vert\\ }\n\\newcommand{\\X}{\\mathbf{X}}\n\\newcommand{\\x}{\\mathbf{x}}\n\\newcommand{\\y}{\\mathbf{y}}\n\\newcommand{\\P}{\\mathcal{P}}\n\\newcommand{\\R}{\\mathbb{R}}\n\\newcommand{\\norm}[1]{\\left\\lVert #1 \\right\\rVert}\n\\newcommand{\\snorm}[1]{\\lVert #1 \\rVert}\n\\newcommand{\\tr}[1]{\\mbox{tr}(#1)}\n\\newcommand{\\brt}{\\widehat{\\beta}^R_{s}}\n\\newcommand{\\brl}{\\widehat{\\beta}^R_{\\lambda}}\n\\newcommand{\\bls}{\\widehat{\\beta}_{ols}}\n\\newcommand{\\blt}{\\widehat{\\beta}^L_{s}}\n\\newcommand{\\bll}{\\widehat{\\beta}^L_{\\lambda}}\n\\newcommand{\\U}{\\mathbf{U}}\n\\newcommand{\\D}{\\mathbf{D}}\n\\newcommand{\\V}{\\mathbf{V}}\n$$\n\n\n\n\n## Attribution\n<br><br>\n\n*This material is based on content adapted from* \n\n- [*Chapters 1, 2.1-2.3, and 4.1-4.3 of An Introduction to Probability and Simulation*](https://bookdown.org/kevin_davisross/probsim-book/)\n\n<br><br>\n\n## Learning Objectives \n<br><br>\n\n- Understand the mechanisms for generating and simulating data.\n- Contrast empirical and theoretical distributions.\n- Use simulations to approximate probability of events or distribution functions.\n- Use simulations to assess theoretical properties of random variables.\n- Explore the Central Limit Theorem (CLT) and Law of Large Numbers (LLN).\n- Write reproducible simulation code.\n- Interpret and reflect on simulation results using plots and summary statistics. \n\n## Last time: Randomness and distributions\n\n- In a **random** phenomenon there is **uncertainty** about which of several potential outcomes will take place. \n  - Outcomes or events may not be equally likely.\n  - Randomness may be the result of physical events, selection, assignment, or complex processes, among others. \n\n- **Probability of events**: a number in $[0, 1]$ that measures the uncertainty of an event.\n\n- A **random variable** assigns numbers to outcomes of a random process\n  - discrete (countable values) or continuous (range of values)\n\n- The **distribution** of a random variable is a function that describes its variability\n  - some of them have formulas and special names  (e.g., Binomial, Uniform, Normal).\n\n#### Today, we’ll use computer code to **simulate randomness** and recreate random processes, under our full control, many times!!\n\n\n## Recall...\n\n\n**Randomness** can come from:\n\n- physical events (e.g, flipping a coin)\n- selection mechanisms (e.g., selecting individuals from a population)\n- experimental designs (random assignment in a controlled experiment)\n- complex systems (e.g., stock market fluctuations)\n\n::: {style=\"color: grey;\"}\n- simulations or algorithms (e.g., random number generator in software)\n:::\n\n- biological processes (e.g., random assortment of chromosomes)\n\nWhich of these random processes can we easily repeat thousands of times? difficult or impossible to reproduce in practice?\n\n#### Simulation lets us recreate random processes in a controlled and repeatable way.\n\n## Simulations\n\n:::callout-important\n## Definition\n\n**Simulation** is a way of recreating a random process with code so that we can repeatedly observe its outcomes and reproduce the same process under identical conditions.\n:::\n\n- Each simulation run randomly results in one possible outcome of the process.\n\n- Many runs reveal patterns of variability in the outcomes of the process.\n\nHowever, \n\n- a real process may be difficult to recreate with code! \n\n- we may need to make many (and some unrealistic) assumptions to recreate a process.\n\n- even when a process is easy to describe, simulating it many times may be computationally costly.\n\n#### Simulation trades analytical difficulty or lack of feasibility for computational effort\n\n## What do we use simulation for?\n\n<br>\n\nWe often use simulation to:\n\n- approximate a probability that it's hard to compute analytically\n\n- approximate a distribution that is unknown or difficult to derive\n\n- understand variability (e.g., a standard error)\n\n- study properties of estimators \n\n#### Simulation answers questions that cannot be answered from a single realization of a random process.\n\n## How do we build a simulation?\n\nTo simulate a process, we follow a clear set of steps.\n\n<br>\n\n::: {.columns}\n\n::: {.column width=\"65%\"}\n\n- 1. Define **the process** we want to simulate\n\n- 2. Specify how **randomness** enters the process\n\n- 3. Decide **what to record** from each run\n\n- 4. **Repeat** the process many times\n\n- 5. **Summarize** the results across runs\n\n:::\n\n::: {.column width=\"35%\"}\n\n![](https://images.unsplash.com/photo-1589152144820-692b189e0b34?q=80&w=1740&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)\n\n::: {style=\"font-size: 13px; margin-top: -30px; color: grey;\"}\nPhoto by <a href=\"https://unsplash.com/@picsbyjameslee?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">James Lee</a> on <a href=\"https://unsplash.com/photos/text-Mfjq1hi-lVg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n:::\n\n:::\n:::\n\n<br>\n\n#### Simulation is structured repetition, not trial and error.\n\n## 1. Define the process\n\n<br>\n\nA simulation always starts with a clearly defined process.\n\n- What is the real or hypothetical process we want to mimic?\n- What assumptions are needed to describe this process?\n- What aspects of the process are held fixed across repetitions?\n\n<br>\n\n#### We simulate the mechanism that generates data, not a single observed outcome.\n\n## Example: approximating a probability by simulation\n\n<br>\n\nOne of the oldest documented problems in probability asks the following question:\n\n> If three fair six-sided dice are rolled, what is more likely: a sum of 9 or a sum of 10?\n\n- use [**this link**](https://www.calculator.net/dice-roller.html) to virtually roll 3 dice\n- record if you get a sum of 9, of 10, or neither\n- repeat 15 times\n- use [**this link**](https://app.sli.do/event/3G8jxQbKQDv3UAZactXrZ2) to share what you found\n\n<br>\n\n::: {style=\"font-size: 20px; margin-top: -30px; color: grey;\"}\nFrom [Probability and Simulation](https://bookdown.org/kevin_davisross/probsim-book/interpretations.html)\n:::\n\n## iCliker 1: define the random process\n\n<br>\n\nWhat is the random process we would repeat many times using code?\n\n- A) Rolling three physical dice in the classroom\n- B) Generating three independent outcomes from \n$\\{1, \\ldots, 6\\}$ with equal probability\n- C) Counting how often sums of 9 and 10 appear in our observed rolls\n- D) Computing the probabilities using a formula\n\n## iCliker 2: add randomness\n\n<br>\n\nIn the three-dice problem, how does randomness enter the process?\n\n- A) The probabilities of each sum are random\n\n- B) The simulation randomly decides whether the sum is 9 or 10\n\n- C) Each die outcome is random, but the chances of each outcome stay the same run to run\n\n- D) The probability of each outcome changes run to run\n\n\n## in R\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nthree_dice <- sample(1:6, size = 3, replace = TRUE)\n\nthree_dice\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 3 2\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(three_dice)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\nEvery time we run this code, we’re simulating one roll of three fair dice! the outcome varies randomly but the probability model is fixed.\n\n#### The code defines the random process by specifying:\n:::incremental\n- what varies\n- what is fixed\n- which function generates the random outcomes (e.g., `sample()`)\n:::\n\n## Record from each run\n\nEvery time we run this code, we’re simulating one roll of three fair dice! What we record from each run??\n\n<br>\n\n#### Back to the 3-dice example\n\n> If three fair six-sided dice are rolled, what is more likely: a sum of 9 or a sum of 10?\n\nYou played with the random generator app and already made a decision of what to record. **What did you record from each run?**\n\nEnter your answer [**here**](https://app.sli.do/event/3G8jxQbKQDv3UAZactXrZ2)\n\n#### All choices are valid, but some are more efficient for the question we want to answer.\n\n## Choice of what to record\n\nWe may record different results from the same random process! \n\n#### What we record from each simulation run depends on the question we are trying to answer.\n\n:::incremental\n- If the goal is to study dice behavior → record all dice\n\n- If the goal is to compare sums → record the sum\n\n- If the goal is a probability → record an indicator\n:::\n\nWe may also record results in anticipation of future questions. \n\nLater, we’ll see how we can make simulations reproducible by controlling the random number generator.\n\n## in R\n\nWrite code to record the following outcomes from one run\n\n- individual outcomes of the 3 dice\n- the sum of the 3 dice\n- indicator variables to record whether the sum is 9 or whether it is 10\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# One run of the process (3 fair dice)\nsample(1:6, size = 3, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 2 5\n```\n\n\n:::\n:::\n\n\n\n\n## Repeat\n\nCompare the result you obtained with others. Did you get the same result?\n\n:::incremental\n- Everyone simulated the same process\n\n- Everyone followed the same instructions\n\n- Everyone most probably got different answers\n:::\n\n> So… which answer is correct?\n\nAll results are correct, but a single run tells us almost nothing about a probability.\n\n#### To approximate probabilities we need the proportion of times events occur across **many runs**.\n\n## in R\n\nYou already repeated the process a few times by hand. Code lets us repeat it thousands of times, consistently!\n\nLet's repeat it $10000$ times!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#sums <- ...(10000, ...(sample(1:6, ..., replace = TRUE)))\n\n#head(sums)\n```\n:::\n\n\n\n## Summarize\n\nOnce we have many runs, we summarize the results to answer our question.\n\n> We approximate each probability by the proportion of runs in which each sum occur.\n\n#### But what we compute depends on what we recorded.\n\nWe can compute the proportion of sums equal to 9 using:\n\n- `mean()` \n\n- `sum()` \n\n- `table()`\n\n## in R\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsums <- replicate(10000,\n  sum(sample(1:6, size = 3, replace = TRUE))\n)\n\nc( prob_9_hat = mean(sums==9),\nprob_10_hat = mean(sums==10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n prob_9_hat prob_10_hat \n     0.1109      0.1250 \n```\n\n\n:::\n:::\n\n\n\n<br>\n\n#### According to our approximation, it seems that the probability of getting a sum of 10 is higher than that of getting 9!\n\n:::callout-caution\nCan you reproduce your result?? Run the code again!\n:::\n\n## Reproducibility\n\n- R generates random outcomes using a random number generator.\n\n- If we fix the starting point of that generator, R can reproduce the same random outcomes! \n\n#### To make a simulation reproducible, we set the seed at any value!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(200)\n\nsums <- replicate(10000,\n  sum(sample(1:6, size = 3, replace = TRUE))\n)\n\nc(prob_9_hat = mean(sums==9),\nprob_10_hat = mean(sums==10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n prob_9_hat prob_10_hat \n     0.1159      0.1213 \n```\n\n\n:::\n:::\n\n\n\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\n\nthree_dice_df <- data.frame(\n  runs = seq_along(sums),\n  `prob_9_hat`  = cumsum(sums == 9)  / seq_along(sums),\n  `prob_10_hat` = cumsum(sums == 10) / seq_along(sums)\n)\n\nthree_dice_long <- tidyr::pivot_longer(\n  three_dice_df,\n  -runs,\n  names_to = \"event\",\n  values_to = \"estimate\"\n)\n\np_long_run <- ggplot(three_dice_long, aes(x = runs, y = estimate, color = event)) +\n  geom_line() +\n  geom_hline(yintercept = c(25, 27)/216,\n             linetype = \"dashed\",\n             color = c(\"#1b9e77\", \"#d95f02\")) +\n  labs(\n    x = \"Number of simulation runs\",\n    y = \"Estimated probability\",\n    color = \"\",\n    title = \"Approximating probabilities by simulation\"\n  ) +\n  theme(\n  text = element_text(size = 10),\n  axis.title = element_text(size = 10),\n  axis.text  = element_text(size = 9),\n  legend.title = element_text(size = 9),\n  legend.text  = element_text(size = 9),\n  plot.title = element_text(size = 11)\n)\n```\n:::\n\n\n\nIn this example, the probabilities are not that difficult to compute analytically (horizontal lines).\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np_long_run\n```\n\n::: {.cell-output-display}\n![](simulation-1_files/figure-revealjs/unnamed-chunk-8-1.svg){fig-align='center'}\n:::\n:::\n\n\n\n## iClicker 3: reproducibility\n\nConsider the following 2 codes:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanswer1 <- replicate(10, sum(sample(1:6, size = 3, replace = TRUE)))\n\nset.seed(200) \n\nreplicate(1000, sum(sample(1:6, size = 3, replace = TRUE))) \n\nreplicate(100, sum(sample(1:6, size = 3, replace = TRUE)))\n\nreplicate(10, sum(sample(1:6, size = 3, replace = TRUE)))\n```\n:::\n\n\n\nand\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanswer1 <- replicate(10, sum(sample(1:6, size = 3, replace = TRUE)))\n\nset.seed(200)  \n\nreplicate(1000, sum(sample(1:6, size = 3, replace = TRUE))) \n\nreplicate(100, sum(sample(1:6, size = 3, replace = TRUE))) \n\nanswer1\n```\n:::\n\n\n\n#### Both codes give the same result. **A: TRUE** or **B: FALSE**\n\n## iClicker 4\n\nA population mean can be estimated with a sample mean. But is this a good estimator?\n\nNext class, we will use the wildfire data as an example of a population to answer this question. What is the random process we would simulate?\n\n- A) Calculating the mean temperature from the full wildfire dataset\n- B) Randomly sampling wildfire observations and computing their mean temperature\n- C) Generating temperatures from a theoretical distribution\n- D) Repeating the same wildfire observation many times\n\n## Key takeaways\n\n:::incremental\n- A simulation starts by defining a random process\n  - We must define what can vary, what is fixed, and how randomness is generated.\n\n- What we record from each run depends on the question\n  - The same random process can produce many valid results \n  - Choosing what to record is part of the modeling decision.\n\n- A single run is not informative about probability\n  - Probabilities are approximated using frequencies across many runs, not individual outcomes.\n\n- Repeating the same process many times is needed to study patterns.\n\n- Setting the seed to generate randomness allows reproducibility. \n:::\n",
    "supporting": [
      "simulation-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}